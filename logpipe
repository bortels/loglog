#!/usr/bin/perl

use File::stat;
use Time::localtime;
use vars qw($VERSION);
use IO::Socket;
use Sys::Hostname;
use Data::Dumper;
use Getopt::Long;
$|=1;
# Note that Proc::Daemon, and File::Tail are included inline. 
$host = `hostname -s`; chomp($host);

GetOptions("debug:i" => \$debug, 
    "tag=s" => \$product, 
    "help" => \$help,
    "maxloglength=i" => \$maxloglength,
    "port=s" => \$SyslogPort,
    "priorty=s" => \$priority,
    "facility=s" => \$Facility,
    "server=s" => \$SyslogHost);

if (!$debug) {$debug = 0;}
if (!$SyslogHost) {$SyslogHost = 'scribe';}
if (!$Facility) {$Facility = 'local6';}
if (!$priority) {$priority = 'info';}
if (!$SyslogPort) {$SyslogPort = 514,}
if (!$maxloglength) {$maxloglength = 4000;}
if (!$product) {$product = "unknown";}
if ($help) {
  print STDERR "usage info\n";
  print STDERR " --help  dump this info\n";
  print STDERR " --debug=#\n";
  print STDERR " --tag=tag for log message (loglog-<tag>)\n";
  print STDERR " --maxloglength=#\n";
  print STDERR " --server=syslogserver\n";
  print STDERR " --port=syslogport\n";
  print STDERR " --priority=syslog priority\n";
  print STDERR " --facility=syslog facility\n";
  exit;
}
$already_alive = `ps -ef | grep loglog | grep -v grep` + 0;
if ($already_alive) {
    # print STDERR "Already running\n";
    exit;
}

$loglogname = File::Spec->rel2abs($0);
$mytimestamp = ctime(stat($loglogname)->mtime);

my $continue = 1;
$SIG{TERM} = sub { $continue = 0 };
$SIG{USR1} = sub {
    open(DUMPFILE, ">/var/tmp/loglog.dump") or die "unable to write loglog dump file\n";
    print DUMPFILE "already_alive\n";
    print DUMPFILE Dumper(\$already_alive);
    print DUMPFILE "conf\n";
    print DUMPFILE Dumper(\$conf);
    print DUMPFILE "continue\n";
    print DUMPFILE Dumper(\$continue);
    print DUMPFILE "d\n";
    print DUMPFILE Dumper(\$d);
    print DUMPFILE "debug\n";
    print DUMPFILE Dumper(\$debug);
    print DUMPFILE "Facility\n";
    print DUMPFILE Dumper(\$Facility);
    print DUMPFILE "facility_i\n";
    print DUMPFILE Dumper(\$facility_i);
    print DUMPFILE "filename\n";
    print DUMPFILE Dumper(\$filename);
    print DUMPFILE "files\n";
    print DUMPFILE Dumper(\@files);
    print DUMPFILE "host\n";
    print DUMPFILE Dumper(\$host);
    print DUMPFILE "interval\n";
    print DUMPFILE Dumper(\$interval);
    print DUMPFILE "loglogname\n";
    print DUMPFILE Dumper(\$loglogname);
    print DUMPFILE "maxloglength\n";
    print DUMPFILE Dumper(\$maxloglength);
    print DUMPFILE "message\n";
    print DUMPFILE Dumper(\$message);
    print DUMPFILE "messagelength\n";
    print DUMPFILE Dumper(\$messagelength);
    print DUMPFILE "month\n";
    print DUMPFILE Dumper(\@month);
    print DUMPFILE "msg\n";
    print DUMPFILE Dumper(\$msg);
    print DUMPFILE "mynewtimestamp\n";
    print DUMPFILE Dumper(\$mynewtimestamp);
    print DUMPFILE "mytimestamp\n";
    print DUMPFILE Dumper(\$mytimestamp);
    print DUMPFILE "name\n";
    print DUMPFILE Dumper(\$name);
    print DUMPFILE "names\n";
    print DUMPFILE Dumper(\$nfound);
    print DUMPFILE "pending\n";
    print DUMPFILE Dumper(\$pending);
    print DUMPFILE "pid\n";
    print DUMPFILE Dumper(\$pid);
    print DUMPFILE "priority\n";
    print DUMPFILE Dumper(\$priority);
    print DUMPFILE "priority_i\n";
    print DUMPFILE Dumper(\$priority_i);
    print DUMPFILE "product\n";
    print DUMPFILE Dumper(\$product);
    print DUMPFILE "rin\n";
    print DUMPFILE Dumper(\$rin);
    print DUMPFILE "sent\n";
    print DUMPFILE Dumper(\$sent);
    print DUMPFILE "sentbytes\n";
    print DUMPFILE Dumper(\$sentbytes);
    print DUMPFILE "sock\n";
    print DUMPFILE Dumper(\$sock);
    print DUMPFILE "syslog_facilities\n";
    print DUMPFILE Dumper(\%syslog_facilities);
    print DUMPFILE "SyslogHost\n";
    print DUMPFILE Dumper(\$SyslogHost);
    print DUMPFILE "SyslogPort\n";
    print DUMPFILE Dumper(\$SyslogPort);
    print DUMPFILE "syslog_priorities\n";
    print DUMPFILE Dumper(\%syslog_priorities);
    print DUMPFILE "t\n";
    print DUMPFILE Dumper(\$t);
    print DUMPFILE "thisfiletail\n";
    print DUMPFILE Dumper(\@time);
    print DUMPFILE "timestamp\n";
    print DUMPFILE Dumper(\$timestamp);
    print DUMPFILE "ts\n";
    print DUMPFILE Dumper(\$ts);
    close(DUMPFILE);
};

my %syslog_priorities = (
    emerg         => 0,
    emergency     => 0,
    alert         => 1,
    crit          => 2,
    critical      => 2,
    err           => 3,
    error         => 3,
    warning       => 4,
    notice        => 5,
    info          => 6,
    informational => 6,
    debug         => 7
);

my %syslog_facilities = (
    kern      => 0,
    kernel    => 0,
    user      => 1,
    mail      => 2,
    daemon    => 3,
    system    => 3,
    auth      => 4,
    syslog    => 5,
    internal  => 5,
    lpr       => 6,
    printer   => 6,
    news      => 7,
    uucp      => 8,
    cron      => 9,
    clock     => 9,
    authpriv  => 10,
    security2 => 10,
    ftp       => 11,
    FTP       => 11,
    NTP       => 11,
    audit     => 13,
    alert     => 14,
    clock2    => 15,
    local0    => 16,
    local1    => 17,
    local2    => 18,
    local3    => 19,
    local4    => 20,
    local5    => 21,
    local6    => 22,
    local7    => 23,
);

my @month = qw{Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec};
$pid        = $$,
# print "config is $conf\n";

#these three arrays are tied together, element X of each array correspond to each other.
$pending='';

my $timestamp = localtime(time);
sendlog("status","Startup (program timestamp is $mytimestamp)");

my $rin='';
$interval = 5 * 60; # 5 minutes
$sent=0; $sentbytes=0; $sentmaxlength=0; $nextreport = time + $interval;
sendlog("status","finished init, configured to watch stdin, starting processing of logs");

while (<>) {
    chomp;
    $t=$_;
    my $t = $thisfiletail->read;
    #print "  $t\n";
    if ($t =~ /^\s/ || length($pending) > 65535) {
        # the line starts with whitespace, assume it's a continuation of the prior line
        #   append it to the prior line, include a separator to indicate that we have done so
        # if the line is longer than 64K, send what we have anyway.
        $pending .= " #015 ".$t;
     } else {
        # if there is a prior line send it
        if ($pending ne "") {
            sendlog($product, 'stdin: '.$pending);
           $sent++;
           $sentbytes += length($pending);
           if (length($pending) > $sentmaxlength) { $sentmaxlength = length($pending); }
         }
     # replace the prior buffer (if any) with the new data
     $pending =$t;
     }
}
if (time > $nextreport) { 
    sendlog("status","sent lines=$sent bytes=$sentbytes maxlength=$sentmaxlength");
    $sent=0; $sentbytes=0; $sentmaxlength=0; $nextreport += $interval;
}
$mynewtimestamp = ctime(stat($loglogname)->mtime);
if ($mynewtimestamp ne $mytimestamp) { # Modified! die, and watchdog will restart
    sendlog("status", "program updated, aborting");
    exit;
}

sub sendlog {
    my $sock = new IO::Socket::INET(
        PeerAddr => $SyslogHost,
        PeerPort => $SyslogPort,
        Proto    => 'udp'
    ) or die "Socket could not be created : $!\n";
    my $product   = shift;
    my $msg   = shift || "NO MESSAGE";
    #print "sending log for $product $msg\n";

    my $facility_i = $syslog_facilities{ $Facility } || 21;
    my $priority_i = $syslog_priorities{ $Priority } || 7;

    my $d = ( ( $facility_i << 3 ) | ($priority_i) );

    my @time = CORE::localtime(time);
    my $ts =
        $month[ $time[4] ] . " "
      . ( ( $time[3] < 10 ) ? ( " " . $time[3] ) : $time[3] ) . " "
      . ( ( $time[2] < 10 ) ? ( "0" . $time[2] ) : $time[2] ) . ":"
      . ( ( $time[1] < 10 ) ? ( "0" . $time[1] ) : $time[1] ) . ":"
      . ( ( $time[0] < 10 ) ? ( "0" . $time[0] ) : $time[0] );

    while (length($msg) > $maxloglength) {
        $messagelength = rindex $msg, " ", $maxloglength ; #find the position of the last space before position $maxloglenth
        push @messages, substr($msg, 0, $messagelength);
        $msg = substr($msg, $messagelength); # skip the space
    }
    push @messages, $msg;
    if ($#messages = 1) {
	$message = "<$d>$ts $host loglog-${product}[$pid]: $messages[0]";
        print $sock $message;
        #print  $message,"\n";;
    } else {
        for ($i=0; $i<$#message; $i++){
            $message = "<$d>$ts $host loglog-${product}[$pid]: ($i/$#messages): $messages[$i]";
            print $sock $message;
            #print  $message,"\n";;
        }
    }
    @messages=();
    $sock->close();
}
